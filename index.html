<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Konverson</title>
    <style>
        :root {
            --bg-color: #1a1a1a;
            --text-color: #e0e0e0;
            --board-bg: #2d2d2d;
            --squex-border: #404040;
            --highlight: rgba(255, 255, 255, 0.1);
            
            --color-A: #ff4d4d; 
            --color-C: #00ff00; 
            --color-B: #4d79ff; 
            --color-D: #ffff00; 
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: var(--bg-color);
            color: var(--text-color);
            margin: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
        }

        header {
            text-align: center;
            padding: 1rem;
            width: 100%;
            background: #000;
            box-shadow: 0 2px 5px rgba(0,0,0,0.5);
        }

        h1 { margin: 0; font-size: 1.5rem; }
        p { margin: 5px 0 0; color: #888; font-size: 0.9rem; }

        #game-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
            padding: 20px;
            width: 100%;
            max-width: 1200px; /* Increased slightly to accommodate side-by-side layout */
        }

        #status-bar {
            display: flex;
            justify-content: space-between;
            width: 100%;
            background: #333;
            padding: 10px 20px;
            border-radius: 8px;
            box-sizing: border-box;
        }

        .status-item {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .label { font-size: 0.75rem; text-transform: uppercase; color: #aaa; }
        .value { font-weight: bold; font-size: 1.1rem; }

        /* --- LAYOUT CHANGES START --- */
        #main-area {
            display: flex;
            flex-direction: row;
            gap: 20px;
            align-items: flex-start;
            width: 100%;
            justify-content: center;
            flex-wrap: nowrap; /* Prevents wrapping on desktop */
        }

        /* Stats Box (Left) */
        #stats-box {
            background-color: #2d2d2d;
            border: 2px solid #444;
            border-radius: 8px;
            padding: 15px;
            min-width: 180px;
            width: 200px; /* Fixed width for the side panel */
            display: flex;
            flex-direction: column;
            gap: 10px;
            box-shadow: 0 4px 10px rgba(0,0,0,0.3);
            flex-shrink: 0; /* Ensures it doesn't shrink when board gets big */
        }

        #board {
            display: grid;
            gap: 2px;
            background-color: var(--board-bg);
            border: 5px solid #555;
            padding: 5px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
            width: auto; /* Removed width: 100% */
            flex-grow: 1; /* Allows board to take remaining space */
            max-width: 800px; /* Prevents it from getting absurdly large */
        }

        /* Mobile Responsiveness: Stack them again if screen is small */
        @media (max-width: 850px) {
            #main-area {
                flex-wrap: wrap;
            }
            #stats-box {
                width: 100%;
                flex-direction: row; /* Layout stats horizontally on mobile */
                justify-content: space-around;
                flex-wrap: wrap;
            }
            #stats-box h3 {
                width: 100%;
            }
            #board {
                width: 100%;
            }
        }
        /* --- LAYOUT CHANGES END --- */

        #stats-box h3 {
            margin: 0 0 10px 0;
            text-align: center;
            font-size: 1rem;
            color: #ccc;
            border-bottom: 1px solid #444;
            padding-bottom: 5px;
        }

        .stat-row {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 8px;
            border-radius: 4px;
            transition: background-color 0.3s;
        }

        .stat-row.active {
            background-color: rgba(255, 255, 255, 0.1);
            border-left: 3px solid #fff;
        }

        .color-label {
            display: flex;
            align-items: center;
            gap: 10px;
            font-weight: bold;
        }

        .dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            display: inline-block;
        }
        .dot.bg-A { background-color: var(--color-A); box-shadow: 0 0 5px var(--color-A); }
        .dot.bg-B { background-color: var(--color-B); box-shadow: 0 0 5px var(--color-B); }
        .dot.bg-C { background-color: var(--color-C); box-shadow: 0 0 5px var(--color-C); }
        .dot.bg-D { background-color: var(--color-D); box-shadow: 0 0 5px var(--color-D); }

        .count { font-family: monospace; font-size: 1.1rem; }

        .squex {
            background-color: #383838;
            border-radius: 2px;
            position: relative;
            cursor: pointer;
            transition: background 0.2s;
            display: flex;
            justify-content: center;
            align-items: center;
            aspect-ratio: 1 / 1;
        }

        .squex:hover { background-color: #444; }
        .squex.valid-move { background-color: rgba(100, 255, 100, 0.15); box-shadow: inset 0 0 5px rgba(100,255,100,0.3); }
        .squex.invalid-move { cursor: not-allowed; }
        
        .coord {
            position: absolute;
            font-size: 8px;
            color: #555;
            pointer-events: none;
        }
        .coord.tl { top: 1px; left: 2px; }

        .pawn {
            width: 70%;
            height: 70%;
            transition: all 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            box-shadow: 0 2px 4px rgba(0,0,0,0.6);
            z-index: 2;
        }

        .pawn.new { border-radius: 3px; border: 2px solid #fff; }
        .pawn.old { border-radius: 50%; border: 2px solid rgba(0,0,0,0.2); transform: scale(0.9); }

        .pawn.color-A { background-color: var(--color-A); }
        .pawn.color-B { background-color: var(--color-B); }
        .pawn.color-C { background-color: var(--color-C); }
        .pawn.color-D { background-color: var(--color-D); }

        @keyframes popIn {
            0% { transform: scale(0); opacity: 0; }
            100% { transform: scale(1); opacity: 1; }
        }
        .pawn.appearing { animation: popIn 0.3s ease-out; }

        /* Conversion Animation */
        .pawn.converting { position: relative; }
        .pawn.converting::after {
            content: '';
            position: absolute;
            top: -2px; left: -2px; right: -2px; bottom: -2px; 
            background-color: var(--old-color);
            border-radius: 50%; 
            z-index: 5;
            pointer-events: none;
            animation: piecemealErode 3s ease-in-out forwards;
        }

        @keyframes piecemealErode {
            0% { clip-path: circle(100%); }
            100% { clip-path: circle(0%); opacity: 0; }
        }

        /* Winning Animation */
        @keyframes winPulse {
            0% { transform: scale(0.9); box-shadow: 0 0 5px rgba(255,255,255,0.8); z-index: 10; }
            50% { transform: scale(1.15); box-shadow: 0 0 20px rgba(255,255,255,1), 0 0 30px currentColor; z-index: 10; }
            100% { transform: scale(0.9); box-shadow: 0 0 5px rgba(255,255,255,0.8); z-index: 10; }
        }
        
        .pawn.winning {
            animation: winPulse 1.2s infinite ease-in-out;
            border-color: #fff !important;
            border-width: 3px !important;
        }

        #controls {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            justify-content: center;
        }

        button {
            background: #444;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
        }
        button:hover { background: #555; }
        button:disabled { opacity: 0.5; cursor: not-allowed; }
        
        select {
            background: #444;
            color: white;
            border: 1px solid #555;
            padding: 10px;
            border-radius: 4px;
            font-weight: bold;
        }

        #ai-status {
            font-size: 0.8rem;
            color: #888;
            width: 100%;
            text-align: center;
            margin-top: 5px;
        }

        #message-area {
            height: 20px;
            color: #ff6b6b;
            font-weight: bold;
            font-size: 0.9rem;
            text-align: center;
        }
    </style>
</head>
<body>

<header>
    <h1>Konverson</h1>    
</header>

<div id="game-container">
    <div id="status-bar">
        <div class="status-item">
            <span class="label">Turn</span>
            <span class="value" id="current-player-display">Player A</span>
        </div>
        <div class="status-item">
            <span class="label">Placements Left</span>
            <span class="value" id="placements-left">1</span>
        </div>
        <div class="status-item">
            <span class="label">Status</span>
            <span class="value" id="game-status">Active</span>
        </div>
    </div>

    <div id="message-area"></div>

    <div id="main-area">
        <div id="stats-box">
            <h3>Turn Succession</h3>
            <div class="stat-row" id="stat-A"><div class="color-label"><span class="dot bg-A"></span> Color A</div><span class="count">0</span></div>
            <div class="stat-row" id="stat-B"><div class="color-label"><span class="dot bg-B"></span> Color B</div><span class="count">0</span></div>
            <div class="stat-row" id="stat-C"><div class="color-label"><span class="dot bg-C"></span> Color C</div><span class="count">0</span></div>
            <div class="stat-row" id="stat-D"><div class="color-label"><span class="dot bg-D"></span> Color D</div><span class="count">0</span></div>
        </div>

        <div id="board"></div>
    </div>

    <div id="controls">
        <button id="btn-reset">New Game</button>
        <select id="ai-difficulty">
            <option value="1">Easy (Depth 1)</option>
            <option value="2" selected>Normal (Depth 2)</option>
            <option value="3">Hard (Depth 3)</option>
            <option value="4">Deep (Depth 4)</option>
            <option value="5">Master (Depth 5)</option>
        </select>
        <select id="board-size">
            <option value="9">9 x 9</option>
            <option value="11">11 x 11</option>
            <option value="13" selected>13 x 13</option>
            <option value="15">15 x 15</option>
        </select>
        <div id="ai-status"></div>
    </div>
</div>

<script id="game-logic">
/**
 * Shared Game Logic & AI
 */
const DEFAULT_BOARD_SIZE = 13;
const COLORS = ['A', 'B', 'C', 'D'];
const TEAMS = { 'A': 'AC', 'C': 'AC', 'B': 'BD', 'D': 'BD' };
const PAWN_NEW = 'new';
const PAWN_OLD = 'old';
const DIRS = [[-1, -1], [-1, 0], [-1, 1], [0, -1], [0, 1], [1, -1], [1, 0], [1, 1]];
const ZONE_INTERIOR = 0; const ZONE_PREBORDER = 1; const ZONE_BORDER = 2; const ZONE_CORNER = 3;

class Pawn {
    constructor(color, posture = PAWN_NEW) {
        this.color = color;
        this.posture = posture;
        this.id = Math.random().toString(36).substr(2, 9);
        this.prevColor = null; 
    }
}

class GameState {
    constructor(size = DEFAULT_BOARD_SIZE) {
        this.size = size;
        this.grid = Array(size).fill(null).map(() => Array(size).fill(null));
        this.turnIndex = 0; 
        this.placementsLeft = 1;
        this.isFirstMoveOfMatch = true;
        this.firstPawnLoc = null;
        this.winner = null;
        this.winningPath = null;
        this.zobristTable = [];
        this.initZobrist();
    }

    static fromData(data) {
        const game = new GameState(data.size);
        game.turnIndex = data.turnIndex;
        game.placementsLeft = data.placementsLeft;
        game.isFirstMoveOfMatch = data.isFirstMoveOfMatch;
        game.firstPawnLoc = data.firstPawnLoc;
        game.winner = data.winner;
        game.winningPath = data.winningPath;
        
        for(let r=0; r<data.size; r++) {
            for(let c=0; c<data.size; c++) {
                if(data.grid[r][c]) {
                    const pData = data.grid[r][c];
                    const p = new Pawn(pData.color, pData.posture);
                    p.id = pData.id;
                    p.prevColor = pData.prevColor;
                    game.grid[r][c] = p;
                }
            }
        }
        return game;
    }

    initZobrist() {
        for(let i=0; i<this.size * this.size * 8; i++) {
            this.zobristTable.push(Math.floor(Math.random() * 2147483648));
        }
    }

    computeHash() {
        let h = 0;
        for(let r=0; r<this.size; r++) {
            for(let c=0; c<this.size; c++) {
                const p = this.grid[r][c];
                if(p) {
                    const colorIdx = COLORS.indexOf(p.color);
                    const postIdx = p.posture === PAWN_NEW ? 0 : 1;
                    const idx = (r * this.size + c) * 8 + (colorIdx * 2 + postIdx);
                    h ^= this.zobristTable[idx];
                }
            }
        }
        return h;
    }

    clone() {
        const newGame = new GameState(this.size);
        for(let r=0; r<this.size; r++) {
            for(let c=0; c<this.size; c++) {
                if (this.grid[r][c]) {
                    newGame.grid[r][c] = {
                        color: this.grid[r][c].color,
                        posture: this.grid[r][c].posture,
                        id: this.grid[r][c].id,
                        prevColor: this.grid[r][c].prevColor
                    };
                }
            }
        }
        newGame.turnIndex = this.turnIndex;
        newGame.placementsLeft = this.placementsLeft;
        newGame.isFirstMoveOfMatch = this.isFirstMoveOfMatch;
        newGame.firstPawnLoc = this.firstPawnLoc ? {...this.firstPawnLoc} : null;
        newGame.winner = this.winner;
        newGame.winningPath = this.winningPath ? [...this.winningPath] : null;
        return newGame;
    }

    getCurrentColor() { return COLORS[this.turnIndex]; }

    getZone(r, c) {
        const last = this.size - 1;
        if ((r===0 && c===0) || (r===0 && c===last) || (r===last && c===0) || (r===last && c===last)) return ZONE_CORNER;
        if (r===0 || r===last || c===0 || c===last) return ZONE_BORDER;
        if (r===1 || r===last-1 || c===1 || c===last-1) return ZONE_PREBORDER;
        return ZONE_INTERIOR;
    }

    hasNeighbor(r, c) {
        for (let d of DIRS) {
            const nr = r + d[0], nc = c + d[1];
            if (nr >= 0 && nr < this.size && nc >= 0 && nc < this.size) {
                if (this.grid[nr][nc]) return true;
            }
        }
        return false;
    }

    hasDiagonalPreborderNeighbor(r, c) {
        const dr = (r === 0) ? 1 : -1; const dc = (c === 0) ? 1 : -1;
        const nr = r + dr; const nc = c + dc;
        return (this.grid[nr][nc] !== null);
    }

    isValidMove(r, c) {
        if (this.winner) return false;
        if (this.grid[r][c] !== null) return false; 
        if (this.firstPawnLoc) {
            const dist = Math.max(Math.abs(r - this.firstPawnLoc.r), Math.abs(c - this.firstPawnLoc.c));
            if (dist < 3) return false;
        }
        const zone = this.getZone(r, c);
        if (zone === ZONE_INTERIOR) return true;
        if (zone === ZONE_PREBORDER) return this.hasNeighbor(r, c);
        if (zone === ZONE_BORDER) return this.hasNeighbor(r, c); 
        if (zone === ZONE_CORNER) return this.hasDiagonalPreborderNeighbor(r, c);
        return false;
    }

    getAllLegalMoves() {
        const moves = [];
        for(let r=0; r<this.size; r++) {
            for(let c=0; c<this.size; c++) {
                if (this.isValidMove(r, c)) moves.push({r, c});
            }
        }
        return moves;
    }

    placePawn(r, c) {
        if (!this.isValidMove(r, c)) return false;
        // Clean flags
        for(let rr=0; rr<this.size; rr++) {
            for(let cc=0; cc<this.size; cc++) {
                if (this.grid[rr][cc]) delete this.grid[rr][cc].convertedRecently;
            }
        }
        const color = this.getCurrentColor();
        this.grid[r][c] = new Pawn(color, PAWN_NEW);
        this.performConversions(r, c, color);
        if (this.checkWin(color)) { this.winner = color; return true; }
        this.placementsLeft--;
        if (this.placementsLeft === 0) this.endTurn();
        else {
            this.firstPawnLoc = {r, c};
            if (this.getAllLegalMoves().length === 0) this.endTurn();
        }
        return true;
    }

    performConversions(r, c, myColor) {
        for (let d of DIRS) {
            const path = [];
            let currR = r + d[0], currC = c + d[1];
            let foundPincer = false;
            let lineEnemyColor = null; 
            while (currR >= 0 && currR < this.size && currC >= 0 && currC < this.size) {
                const p = this.grid[currR][currC];
                if (!p) break;
                if (p.color === myColor) { foundPincer = true; break; }
                if (p.posture === PAWN_NEW) break;
                if (lineEnemyColor === null) lineEnemyColor = p.color;
                else if (p.color !== lineEnemyColor) break; 
                path.push({r: currR, c: currC, pawn: p});
                currR += d[0]; currC += d[1];
            }
            if (foundPincer && path.length > 0) {
                for (let item of path) {
                    item.pawn.prevColor = item.pawn.color; 
                    item.pawn.color = myColor;
                    item.pawn.convertedRecently = true;
                }
            }
        }
    }

    endTurn() {
        this.isFirstMoveOfMatch = false;
        this.turnIndex = (this.turnIndex + 1) % 4;
        const nextColor = COLORS[this.turnIndex];
        for(let r=0; r<this.size; r++) {
            for(let c=0; c<this.size; c++) {
                const p = this.grid[r][c];
                if (p && p.color === nextColor && p.posture === PAWN_NEW) p.posture = PAWN_OLD;
            }
        }
        this.placementsLeft = 2;
        this.firstPawnLoc = null;
        if (this.getAllLegalMoves().length === 0) this.winner = 'Draw';
    }

    checkWin(color) {
        let startNodesNS = [];
        for(let c=1; c<this.size-1; c++) {
            if(this.grid[0][c] && this.grid[0][c].color === color) startNodesNS.push({r:0, c:c});
        }
        let path = this.bfsConnection(startNodesNS, color, 'NS');
        if (path) { this.winningPath = path; return true; }
        let startNodesWE = [];
        for(let r=1; r<this.size-1; r++) {
            if(this.grid[r][0] && this.grid[r][0].color === color) startNodesWE.push({r:r, c:0});
        }
        path = this.bfsConnection(startNodesWE, color, 'WE');
        if (path) { this.winningPath = path; return true; }
        return false;
    }

    bfsConnection(startNodes, color, type) {
        let queue = [], visited = new Set(), parentMap = new Map();
        for (let node of startNodes) {
            queue.push(node);
            visited.add(`${node.r},${node.c}`);
            parentMap.set(`${node.r},${node.c}`, null);
        }
        let head = 0;
        while(head < queue.length) {
            const curr = queue[head++];
            if ((type === 'NS' && curr.r === this.size - 1) || (type === 'WE' && curr.c === this.size - 1)) {
                let path = [], currKey = `${curr.r},${curr.c}`;
                while (currKey) {
                    const [r, c] = currKey.split(',').map(Number);
                    path.push({r, c});
                    const parent = parentMap.get(currKey);
                    currKey = parent ? `${parent.r},${parent.c}` : null;
                }
                return path;
            }
            for(let d of DIRS) {
                const nr = curr.r + d[0], nc = curr.c + d[1];
                if (this.getZone(nr, nc) === ZONE_CORNER) continue;
                if (nr >= 0 && nr < this.size && nc >= 0 && nc < this.size) {
                    const key = `${nr},${nc}`;
                    if (!visited.has(key)) {
                        const p = this.grid[nr][nc];
                        if (p && p.color === color) {
                            visited.add(key);
                            parentMap.set(key, {r: curr.r, c: curr.c});
                            queue.push({r:nr, c:nc});
                        }
                    }
                }
            }
        }
        return null;
    }
}

class AI {
    constructor() {
        this.ttSize = 0x100000; 
        this.transpositionTable = new Array(this.ttSize).fill(null);
        this.maxDepth = 3;
        this.nodesVisited = 0;
    }

    getCandidateMoves(game) {
        const allLegal = game.getAllLegalMoves();
        let isEmpty = true;
        for(let r=0; r<game.size; r++) {
            for(let c=0; c<game.size; c++) {
                if(game.grid[r][c]) { isEmpty = false; break; }
            }
            if(!isEmpty) break;
        }
        if (isEmpty) return allLegal;
        const contactMoves = allLegal.filter(m => game.hasNeighbor(m.r, m.c));
        return contactMoves.length > 0 ? contactMoves : allLegal;
    }

    orderMoves(game, moves) {
        moves.sort((a, b) => {
            if (a.score !== undefined && b.score !== undefined) return b.score - a.score;
            const distA = Math.abs(a.r - game.size/2) + Math.abs(a.c - game.size/2);
            const distB = Math.abs(b.r - game.size/2) + Math.abs(b.c - game.size/2);
            return distA - distB; 
        });
    }

    evaluate(game) {
        const color = game.getCurrentColor();
        const ally = TEAMS[color] === 'AC' ? (color==='A'?'C':'A') : (color==='B'?'D':'B');
        
        if (game.winner) {
            if (game.winner === 'Draw') return 0;
            if (game.winner === color || game.winner === ally) return 10000000;
            return -10000000;
        }
        
        let score = 0;
        let myCount = 0;
        let enemyCount = 0;

        for(let r=0; r<game.size; r++) {
            for(let c=0; c<game.size; c++) {
                const p = game.grid[r][c];
                if(p) {
                    let val = 40; 
                    if (p.posture === PAWN_NEW) val += 5;
                    const distCenter = Math.abs(r - game.size/2) + Math.abs(c - game.size/2);
                    val += (game.size - distCenter);
                    
                    if(p.color === color || p.color === ally) {
                        score += val; myCount++;
                    } else {
                        score -= val; enemyCount++;
                    }
                }
            }
        }
        score += (myCount - enemyCount) * 1000;
        return score;
    }

    alphaBeta(game, depth, alpha, beta, isPvNode) {
        this.nodesVisited++;
        const hash = game.computeHash();
        const ttIndex = Math.abs(hash) % this.ttSize;
        const ttEntry = this.transpositionTable[ttIndex];

        if (ttEntry && ttEntry.hash === hash && ttEntry.depth >= depth) {
            if (ttEntry.flag === 'exact') return ttEntry.score;
            if (ttEntry.flag === 'lower' && ttEntry.score > alpha) alpha = ttEntry.score;
            if (ttEntry.flag === 'upper' && ttEntry.score < beta) beta = ttEntry.score;
            if (alpha >= beta) return ttEntry.score;
        }

        if (game.winner) return this.evaluate(game);
        if (depth === 0) return this.evaluate(game);

        const moves = this.getCandidateMoves(game);
        if (moves.length === 0) return this.evaluate(game);

        this.orderMoves(game, moves);
        
        let bestScore = -Infinity;
        let moveCount = 0;
        let ttFlag = 'upper';

        for (let move of moves) {
            moveCount++;
            const clone = game.clone();
            clone.placePawn(move.r, move.c);
            let score;
            
            // FIX: Self-Sabotage Check
            const nextColor = clone.getCurrentColor();
            const currColor = game.getCurrentColor();

            if (nextColor === currColor) {
                // Same Turn -> Maximize
                score = this.alphaBeta(clone, depth - 1, alpha, beta, true);
            } else {
                // Turn Change -> NegaMax
                score = -this.alphaBeta(clone, depth - 1, -beta, -alpha, true);
            }

            if (score > bestScore) bestScore = score;
            if (score > alpha) {
                alpha = score;
                ttFlag = 'exact';
            }
            if (alpha >= beta) {
                ttFlag = 'lower';
                break;
            }
        }

        this.transpositionTable[ttIndex] = { hash, score: bestScore, depth, flag: ttFlag };
        return bestScore;
    }

    searchRootSubset(game, movesToSearch, targetDepth, timeLimit) {
        this.nodesVisited = 0;
        this.transpositionTable.fill(null); // Clear TT for new search
        
        let bestMove = null;
        let bestScore = -Infinity;
        const startTime = performance.now();

        // Iterative Deepening
        for (let currentDepth = 1; currentDepth <= targetDepth; currentDepth++) {
            if (performance.now() - startTime > timeLimit) break;

            if (currentDepth > 1) this.orderMoves(game, movesToSearch);

            let iterationBestScore = -Infinity;
            let iterationBestMove = null;
            let alpha = -Infinity;
            let beta = Infinity;

            for (let move of movesToSearch) {
                const clone = game.clone();
                clone.placePawn(move.r, move.c);
                
                const nextColor = clone.getCurrentColor();
                const currColor = game.getCurrentColor();
                let score;

                if (nextColor === currColor) {
                    score = this.alphaBeta(clone, currentDepth - 1, alpha, beta, true);
                } else {
                    score = -this.alphaBeta(clone, currentDepth - 1, -beta, -alpha, true);
                }
                
                move.score = score;

                if (score > iterationBestScore) {
                    iterationBestScore = score;
                    iterationBestMove = move;
                }
                alpha = Math.max(alpha, iterationBestScore);
                
                // Check time every move at root
                if (performance.now() - startTime > timeLimit) break;
            }
            
            if (performance.now() - startTime <= timeLimit) {
                bestScore = iterationBestScore;
                bestMove = iterationBestMove;
            }
        }

        return {
            bestMove: bestMove,
            score: bestScore,
            nodesVisited: this.nodesVisited
        };
    }
}
</script>

<script>
/**
 * Main UI Script
 */

const logicSource = document.getElementById('game-logic').textContent;
const workerHandlerSource = `
self.onmessage = function(e) {
    const { gameStateData, movesToSearch, depth, timeout } = e.data;
    const game = GameState.fromData(gameStateData);
    const ai = new AI();
    const result = ai.searchRootSubset(game, movesToSearch, depth, timeout);
    postMessage(result);
};
`;

const blob = new Blob([logicSource + workerHandlerSource], {type: 'application/javascript'});
const workerUrl = URL.createObjectURL(blob);

class ParallelAI {
    constructor() {
        this.numWorkers = navigator.hardwareConcurrency || 4;
        this.localAI = new AI(); 
    }

    async getBestMoveParallel(game, depth) {
        const candidates = this.localAI.getCandidateMoves(game);
        
        if (candidates.length === 0) return null;
        if (candidates.length === 1) return candidates[0];

        this.localAI.orderMoves(game, candidates);

        const chunks = Array.from({length: this.numWorkers}, () => []);
        candidates.forEach((move, i) => {
            chunks[i % this.numWorkers].push(move);
        });

        // 5 Second Hard Time Limit for Workers
        const TIMEOUT = 5000;

        const promises = chunks.map((chunk, i) => {
            if (chunk.length === 0) return Promise.resolve(null);
            
            return new Promise((resolve, reject) => {
                const worker = new Worker(workerUrl);
                
                worker.onmessage = (e) => {
                    resolve(e.data);
                    worker.terminate();
                };
                
                worker.onerror = (err) => {
                    console.error("Worker Error:", err);
                    reject(err);
                    worker.terminate();
                };

                worker.postMessage({
                    gameStateData: game, 
                    movesToSearch: chunk,
                    depth: depth,
                    timeout: TIMEOUT
                });
            });
        });

        const statusDiv = document.getElementById('ai-status');
        statusDiv.innerText = `Dispatching ${candidates.length} moves...`;

        const results = await Promise.all(promises);
        
        let globalBestScore = -Infinity;
        let globalBestMove = null;
        let totalNodes = 0;

        results.forEach(res => {
            if (res) {
                totalNodes += res.nodesVisited;
                if (res.score > globalBestScore) {
                    globalBestScore = res.score;
                    globalBestMove = res.bestMove;
                }
            }
        });

        console.log(`Parallel Search Completed. Nodes: ${totalNodes}, Score: ${globalBestScore}`);
        statusDiv.innerText = `Visited ${totalNodes} nodes.`;
        
        return globalBestMove;
    }
}

const boardEl = document.getElementById('board');
const statusDisplay = document.getElementById('current-player-display');
const placementsDisplay = document.getElementById('placements-left');
const statusText = document.getElementById('game-status');
const msgArea = document.getElementById('message-area');
const btnReset = document.getElementById('btn-reset');
const diffSelect = document.getElementById('ai-difficulty');
const sizeSelect = document.getElementById('board-size');
const aiStatus = document.getElementById('ai-status');

const AI_TEAMS = ['B', 'D']; 

let game = new GameState();
const parallelAI = new ParallelAI();
let uiLocked = false;

function initUI() {
    const size = game.size;
    boardEl.style.gridTemplateColumns = `repeat(${size}, 1fr)`;
    boardEl.innerHTML = '';
    
    for(let r=0; r<size; r++) {
        for(let c=0; c<size; c++) {
            const sq = document.createElement('div');
            sq.className = 'squex';
            sq.dataset.r = r;
            sq.dataset.c = c;
            
            const coord = document.createElement('span');
            coord.className = 'coord tl';
            sq.appendChild(coord);

            sq.addEventListener('click', () => handleSquareClick(r, c));
            boardEl.appendChild(sq);
        }
    }
    render();
}

async function gameLoop() {
    const currentColor = game.getCurrentColor();
    if (game.winner) return;

    if (AI_TEAMS.includes(currentColor)) {
        uiLocked = true;
        msgArea.innerText = `AI (${currentColor}) Thinking...`;
        setTimeout(() => executeAIMove(), 100); 
    } else {
        uiLocked = false;
        msgArea.innerText = `Your Turn (${currentColor})`;
    }
}

async function executeAIMove() {
    if (game.winner) return;
    const processingGame = game; 
    const depth = parseInt(diffSelect.value);
    
    try {
        const move = await parallelAI.getBestMoveParallel(processingGame, depth);
        if (game !== processingGame) return;

        if (move) {
            game.placePawn(move.r, move.c);
            render();
            if (game.winner) handleWin();
            else setTimeout(gameLoop, 500); 
        } else {
            msgArea.innerText = "AI Resigns";
            handleWin(); 
        }
    } catch (e) {
        console.error(e);
        msgArea.innerText = "AI Error";
    }
}

function handleSquareClick(r, c) {
    if (game.winner || uiLocked) return;
    msgArea.innerText = "";
    if (game.placePawn(r, c)) {
        render();
        if (game.winner) handleWin();
        else gameLoop(); 
    } else {
        msgArea.innerText = "Invalid Move! Check rules.";
        const sq = document.querySelector(`.squex[data-r='${r}'][data-c='${c}']`);
        sq.classList.add('invalid-move');
        setTimeout(() => sq.classList.remove('invalid-move'), 500);
    }
}

function handleWin() {
    statusText.innerText = "GAME OVER";
    statusText.style.color = "#4dff4d";
    if (game.winner === 'Draw') {
        msgArea.innerText = "Stalemate!";
    } else {
        msgArea.innerText = `Victory for Color ${game.winner}!`;
    }
    uiLocked = true;
    render();
}

function render() {
    const size = game.size;
    for(let r=0; r<size; r++) {
        for(let c=0; c<size; c++) {
            const sq = document.querySelector(`.squex[data-r='${r}'][data-c='${c}']`);
            const existingPawn = sq.querySelector('.pawn');
            const p = game.grid[r][c];

            if (!p && existingPawn) {
                existingPawn.remove();
                continue;
            }

            if (p) {
                let pawnDiv = existingPawn;
                if (!pawnDiv || pawnDiv.dataset.id !== p.id) {
                    if (pawnDiv) pawnDiv.remove();
                    pawnDiv = document.createElement('div');
                    pawnDiv.dataset.id = p.id;
                    sq.appendChild(pawnDiv);
                    if (game.firstPawnLoc && game.firstPawnLoc.r === r && game.firstPawnLoc.c === c) {
                        pawnDiv.classList.add('appearing');
                    }
                }
                pawnDiv.className = `pawn color-${p.color} ${p.posture}`;

                if (p.convertedRecently) {
                    pawnDiv.classList.add('converting');
                    pawnDiv.style.setProperty('--old-color', `var(--color-${p.prevColor})`);
                } else {
                    pawnDiv.classList.remove('converting');
                    pawnDiv.style.removeProperty('--old-color');
                }

                if (game.winningPath) {
                    const isWinning = game.winningPath.some(wp => wp.r === r && wp.c === c);
                    if (isWinning) {
                        pawnDiv.classList.add('winning');
                    } else {
                        pawnDiv.classList.remove('winning');
                    }
                }
            }
            sq.classList.remove('valid-move');
        }
    }

    if (!game.winner) {
        for(let r=0; r<size; r++) {
            for(let c=0; c<size; c++) {
                if (game.isValidMove(r, c)) {
                    const sq = document.querySelector(`.squex[data-r='${r}'][data-c='${c}']`);
                    sq.classList.add('valid-move');
                }
            }
        }
    }
    updateStatus();
}

function updateStatus() {
    const c = game.getCurrentColor();
    statusDisplay.innerText = `Player ${c}`;
    statusDisplay.style.color = `var(--color-${c})`;
    placementsDisplay.innerText = game.placementsLeft;
    
    const counts = { A: 0, B: 0, C: 0, D: 0 };
    for(let r=0; r<game.size; r++) {
        for(let c=0; c<game.size; c++) {
            const p = game.grid[r][c];
            if(p) counts[p.color]++;
        }
    }
    
    document.querySelector('#stat-A .count').innerText = counts.A;
    document.querySelector('#stat-B .count').innerText = counts.B;
    document.querySelector('#stat-C .count').innerText = counts.C;
    document.querySelector('#stat-D .count').innerText = counts.D;
    
    ['A','B','C','D'].forEach(color => {
        const row = document.getElementById(`stat-${color}`);
        if(color === c) row.classList.add('active');
        else row.classList.remove('active');
    });
}

btnReset.addEventListener('click', () => {
    const size = parseInt(sizeSelect.value);
    game = new GameState(size);
    uiLocked = false;
    statusText.innerText = "Active";
    statusText.style.color = "#eee";
    msgArea.innerText = "";
    aiStatus.innerText = "";
    initUI(); 
    gameLoop(); 
});

initUI();
gameLoop();

</script>
</body>
</html>
